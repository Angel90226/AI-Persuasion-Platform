"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateruby_openai"]("main",{

/***/ "./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./frontend_app/pages/PreTask.vue?vue&type=script&lang=js":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./frontend_app/pages/PreTask.vue?vue&type=script&lang=js ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue-router */ \"./node_modules/vue-router/dist/vue-router.mjs\");\n/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vuex */ \"./node_modules/vuex/dist/vuex.esm-bundler.js\");\n/* harmony import */ var _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant/Constants.vue */ \"./frontend_app/constant/Constants.vue\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! axios */ \"./node_modules/axios/lib/axios.js\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! marked */ \"./node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _mdi_font_css_materialdesignicons_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mdi/font/css/materialdesignicons.css */ \"./node_modules/@mdi/font/css/materialdesignicons.css\");\n/* harmony import */ var _mdi_font_css_materialdesignicons_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_mdi_font_css_materialdesignicons_css__WEBPACK_IMPORTED_MODULE_3__);\n/* unplugin-vue-components disabled */\n\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  setup() {\n    const route = (0,vue_router__WEBPACK_IMPORTED_MODULE_4__.useRoute)()\n    const router = (0,vue_router__WEBPACK_IMPORTED_MODULE_4__.useRouter)()\n    const store = (0,vuex__WEBPACK_IMPORTED_MODULE_5__.useStore)()\n    const showRoleDialog = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(true)\n    const userInput = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('')\n    const messages = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([])\n    const showTyping = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false)\n    const showEmail = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false)\n    const roleDescription = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('')\n    const isLoadingRole = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(true);\n    const emailLongRequirement = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].OFFICEBOT_EMAIL_REQUIREMENT)\n    const officebotIntro = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('')\n    const currentTemp = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].DEFAULTS_TEMP)\n    const messageSending = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n    const user_id = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('anonymous');\n    const isReadyToSend = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n    let userStartTime=null\n    let userSendTime=null\n    let AIStartTime=null\n    let localData = {}\n    let tagBuffer = '';\n    let inTag = false;\n\n    // shared store variables\n    const updateSharedVariable = (obj) => {\n      store.commit('updateSharedVariable', obj)\n    }\n\n    ;(0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {\n      console.log('PreTask mounted');\n      getUser();\n      await getCondition();\n      await updateUser();\n    })\n\n    const getUser=async()=> {\n      user_id.value = route.query[_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].URL_USER_PARAMS] || 'anonymous';\n      \n      if(user_id.value === 'anonymous'){\n        router.push({ path: '/missing' })\n      }\n      updateSharedVariable({'user_id': user_id.value});\n      localData['user_id'] = user_id.value\n      // update local storage\n      if (!localStorage.getItem(user_id.value)) {\n        localStorage.setItem(user_id.value, JSON.stringify(localData));\n      } else {\n        const data = localStorage.getItem(user_id.value);\n        localData = JSON.parse(data);\n      }\n    };\n\n    const getCondition = async () => {\n      // check if the condition is set in the url\n      const encodedConditions = route.query[_constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].URL_CONDITION_PARAMS] || 'none';\n      if(encodedConditions !== 'none'){\n        const condition = JSON.parse(atob(encodedConditions))\n        console.log('Test Condition:', condition);\n        localData['condition'] = condition;\n        localStorage.setItem(user_id.value, JSON.stringify(localData))\n      }\n      if(!localData['condition']||localData['condition'].expire_time < new Date().getTime()){\n        try{\n          console.log('Random Condition'); \n          let api_url = \"/random-condition\";\n          if(user_id.value !== 'anonymous'){\n            api_url = `/random-condition?user_id=${user_id.value}`;\n          } \n          const { data } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(api_url);\n          updateSharedVariable({ 'condition': data })\n          data.expire_time = new Date().getTime() + _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].MISSION_EXPIRE_TIME*1000;\n          localData['condition'] = data;\n          localStorage.setItem(user_id.value, JSON.stringify(localData))\n        } catch (error) {\n          console.error('Failed to fetch task:', error);\n          location.reload();\n          sendError({error_message:\"Failed to fetch task:\"+ error});\n        }\n      }\n      if(localData['condition'].power_condition === 'high'){\n        roleDescription.value = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].HIGH_POWER_ROLE_DESCRIPTION;\n        officebotIntro.value = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].HIGH_POWER_OFFICEBOT_INTRO;\n      }else{\n        roleDescription.value = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].LOW_POWER_ROLE_DESCRIPTION;\n        officebotIntro.value = _constant_Constants_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].LOW_POWER_OFFICEBOT_INTRO;\n      }\n      isLoadingRole.value = false;\n    }\n    const updateUser = async () => {\n      try {\n        console.log('Updating user');\n        let api_url = \"/update_user\";\n        if(user_id.value !== 'anonymous'){\n          api_url = `/update_user?user_id=${user_id.value}&power_condition=${localData['condition'].power_condition}&presence_condition=${localData['condition'].presence_condition}`\n          ;\n        } \n        await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].post(api_url, {});\n      } catch (error) {\n        console.error('Failed to update user:', error);\n        sendError({error_message:\"Failed to update user:\"+ error});\n      }\n    }\n\n    ;(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(messages, () => {\n      // Wait for the next DOM update to scroll\n      ;(0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n        scrollToBottom();\n      });\n      \n      // 檢查最新的assistant訊息是否表示準備好送出\n      const lastMsg = messages.value[messages.value.length - 1];\n      if (\n        lastMsg &&\n        lastMsg.type === 'assistant' &&\n        checkReadyToSend(lastMsg.text)\n      ) {\n        handleReadyToSend();\n      }\n    }, { deep: true });\n\n    const onUnderstandClick = async () => {\n      showRoleDialog.value = false;\n      // load messages\n      await initialMessages();\n    }\n    \n    // API related\n    const initialMessages = async ()=>{\n      if (user_id.value === 'anonymous') return;\n      \n      try {\n        showEmail.value = true;\n        let api_url = \"/messages\";\n        if(user_id.value !== 'anonymous'){\n          api_url = `/messages?user_id=${user_id.value}`;\n        } \n        const { data } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(api_url, {\n          headers: {\n            'Cache-Control': 'no-cache',\n            'Pragma': 'no-cache',\n            'Expires': '0',\n          }\n        });\n\n        if(data.length > 0){\n          messages.value = data.map( (chat)=>{\n            return {\n              id: chat.created_at,\n              text: marked__WEBPACK_IMPORTED_MODULE_2__.marked.parse(chat.response),\n              type: chat.role,\n              timestamp: chat.created_at ? new Date(chat.created_at) : new Date(),\n            }\n          });\n          \n          // check if there is any assistant message that indicates ready to send\n          const readyMessage = data.find(chat =>\n            chat.role === 'assistant' && checkReadyToSend(chat.response)\n          );\n          if (readyMessage) {\n            handleReadyToSend();\n          }\n        } else {\n          await streamingResponse();\n        }\n        \n        (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n          scrollToBottom();\n        });\n      } catch (error) {\n        console.error(\"Failed to fetch initial messages:\", error);\n        sendError({error_message:\"Failed to fetch initial messages:\"+ error});\n      }\n    }\n\n    const scrollToBottom = () => {\n      ;(0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n        const container = document.querySelector('.chat-messages')\n        if (container) {\n          container.scrollTop = container.scrollHeight\n        }\n      })\n    }\n\n    const onInputKeyDown = () => {\n      if (!userStartTime) {\n        userStartTime = new Date().toISOString()\n        console.log('User Start Time:', userStartTime);\n      }\n    };\n    //Create a message\n    function createMessage(message,identity) {\n      messages.value.push({\n        id: Date.now(),\n        text: message,\n        type: identity || \"user\",\n        temp: currentTemp.value,\n        timestamp: new Date(),\n      });\n      scrollToBottom();\n    }\n    \n    const handleSend = async () => {\n      userSendTime = new Date().toISOString();\n      if (!userInput.value.trim()) return\n      \n      // Add user message\n      const userMessageText = userInput.value;\n      createMessage(marked__WEBPACK_IMPORTED_MODULE_2__.marked.parse(userMessageText),'user');\n      userInput.value = ''; // Clear input immediately\n      \n      try {\n        // Store message in backend\n        await storeMessage(userMessageText,'user', userStartTime, userSendTime)\n\n        // Get streaming response\n        await streamingResponse()\n\n      } catch (error) {\n        console.error('Error in handleSend:', error)\n        createMessage('Sorry, I encountered an error. Please try again.','assistant');\n      } finally {\n        showTyping.value = false\n        userInput.value = ''\n      }\n    }\n    const storeMessage = async (text, type, start_time, send_time) => {\n      try {\n        const postData = {\n          response: text,\n          role: type,\n          start_time: start_time,\n          send_time: send_time\n      };\n      console.log('Post Data:', postData);\n        let api_url = \"/message\";\n        if(user_id.value !== 'anonymous'){\n          api_url = `/message?user_id=${user_id.value}`;\n        } \n      const { data } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].post(api_url, postData);\n      console.log('Store Message:', data);\n\n      } catch (error) {\n        console.error('Failed to store message:', error)\n        sendError({error_message:\"Failed to store message:\"+ error});\n      }\n    }\n\n    let controller = null;\n\n    // Helper function to animate text display character by character\n    const animateStreamedText = async (token, streaming_message_ref) => {\n      for (let char of token) {\n        if (inTag) {\n          tagBuffer += char;\n          if (char === '>') {\n            // 標籤結束，整個一起 append\n            streaming_message_ref.value += tagBuffer;\n            tagBuffer = '';\n            inTag = false;\n          }\n        } else {\n          if (char === '<') {\n            inTag = true;\n            tagBuffer = '<';\n          } else {\n            streaming_message_ref.value += char;\n          }\n        }\n      }\n      messages.value[messages.value.length - 1][\"text\"] = marked__WEBPACK_IMPORTED_MODULE_2__.marked.parse(streaming_message_ref.value);\n      scrollToBottom();\n\n      // check if there is any assistant message that indicates ready to send\n      if (checkReadyToSend(streaming_message_ref.value)) {\n        handleReadyToSend();\n      }\n\n      // Determine delay based on token content (punctuation can be slower)\n      const delay = getDelay(token);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    };\n\n    const getDelay = (token) => {\n      if (token.match(/[.!?]/)) return 350;\n      if (token.match(/[,;]/)) return 150;\n      return 20 + Math.random() * 40;\n    };\n    \n    // Real-time chat effect\n    const botSendMessage = async (options = {}) => {\n      showTyping.value = true\n      const delay = options.delay || 1000\n      await new Promise(resolve => setTimeout(resolve, delay))\n      showTyping.value = false\n      createMessage('', 'assistant');\n    }\n\n    const streamingResponse = async () => {\n      messageSending.value = true;\n      let insufficient=false;\n      let save_message = '';\n      // 1. streaming 前先 push 一個空的 assistant 訊息\n      const streaming_message = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(''); // Use a ref to pass to the helper function\n      messages.value.push({\n        id: Date.now(),\n        text: '',\n        type: 'assistant',\n        timestamp: new Date(),\n      });\n      let api_url = \"/openAI-streaming\";\n      if(user_id.value !== 'anonymous'){\n        api_url = `/openAI-streaming?user_id=${user_id.value}`\n        ;\n      } \n      controller = new AbortController();\n      const signal = controller.signal;\n      AIStartTime = new Date().toISOString();\n      try {\n        // 不再呼叫 botSendMessage();\n        const response = await fetch(api_url,\n        {\n          method: \"POST\",\n          headers: {\n          \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            message_content: userInput.value,\n            system_temp: currentTemp.value,\n            role: \"user\",\n            start_time: userStartTime,\n            send_time: userSendTime,\n          }),\n          signal,\n        });\n        userInput.value = '';\n        // disabled the sender button\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder(\"utf-8\",{ stream: true });\n        while(true){\n          const {done, value} = await reader.read();\n          if(done){\n            break;\n          }\n          const chunk = decoder.decode(value);\n          const lines = chunk.split(\"\\n\");\n          if(insufficient){\n            lines[0] = save_message + lines[0];\n            insufficient=false;\n          }\n          console.log('Streaming Lines:', lines);\n          const parsedLines = lines\n                .filter((line) => line.trim() !== \"\" && !line.includes(\"[DONE]\"))\n                .map((line) => line.replace(/^data: /, \"\").trim())\n                .map((line) => {\n                  try {\n                    return JSON.parse(line);\n                  } catch (error) {\n                    console.error(\"Failed to parse JSON line:\", line);\n                    insufficient=true;\n                    save_message = line;\n                    console.error(error);\n                    return null;\n                  }\n                })\n                .filter((parsedLine) => parsedLine !== null);\n          for ( const parsedLine of parsedLines){\n            const {choices} = parsedLine;\n            const { delta } = choices[0];\n            const { content } = delta;\n            if(content){\n              await animateStreamedText(content, streaming_message);\n            }\n          }\n        }\n      } catch (error) {\n        if(signal.aborted){\n          console.error('Request Aborted:', error);\n        }else{\n          console.error('Failed to Streaming:', error);\n          sendError({error_message:\"Failed to Streaming:\"+ error});\n        }\n      }finally{\n        controller = null;\n        messageSending.value = false;\n        // send API to backend\n        await storeMessage(streaming_message.value,'assistant', AIStartTime, new Date().toISOString());\n      }\n    }\n\n    const sendError = async (error) => {\n      if (error) {\n        let api_url = \"/error-log\";\n        if (user_id.value !== 'anonymous') {\n          api_url = `/error-log?user_id=${user_id.value}`;\n        }\n        try {\n          const { data } = await axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].post(api_url, error);\n          // console.log('Response Behavior', data);\n        } catch (err) {\n          console.error('Failed to send error:', err);\n          // Handle specific error scenarios here if needed\n        }\n      }\n    }\n\n    const formatTimestamp = (ts) => {\n      if (!ts) return ''\n      const date = typeof ts === 'string' ? new Date(ts) : ts\n      return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })\n    }\n\n    function getTodayString() {\n      const today = new Date();\n      const year = today.getFullYear();\n      const month = String(today.getMonth() + 1).padStart(2, '0');\n      const day = String(today.getDate()).padStart(2, '0');\n      const weekDay = today.toLocaleDateString('en-US', { weekday: 'short' }); // e.g. Mon, Tue\n      return `${year}/${month}/${day} ${weekDay} 9:30 AM`;\n    }\n\n    const todayEmailDate = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(getTodayString());\n\n    // check if the assistant message indicates ready to send\n    const checkReadyToSend = (messageText) => {\n      if (!messageText || typeof messageText !== 'string') return false;\n      \n      const text = messageText.toLowerCase();\n      // more accurate keyword matching, based on the actual response from the backend prompt\n      const sendKeywords = [\n        'okay, i\\'m sending the email',\n        'thank you, i\\'m sending the email',\n      ];\n      \n      const isReady = sendKeywords.some(keyword => text.includes(keyword));\n      \n      // for debugging: record the detection result\n      if (isReady) {\n        console.log('Ready to send detected:', text);\n      }\n      \n      return isReady;\n    };\n\n    // handle the logic of ready to send\n    const handleReadyToSend = () => {\n      if (!isReadyToSend.value) {\n        console.log('Handling ready to send - transitioning to main task');\n        isReadyToSend.value = true;\n        localData.PreTaskCompleted = true;\n        localStorage.setItem(user_id.value, JSON.stringify(localData));\n        setTimeout(() => {\n          router.push({ path: '/main-task', query: route.query });\n        }, 1500);\n      }\n    };\n    // Return variables and methods to be used in the template\n    return {\n      showRoleDialog,\n      userInput,\n      messages,\n      showTyping,\n      messageSending,\n      showEmail,\n      roleDescription,\n      emailLongRequirement,\n      officebotIntro,\n      scrollToBottom,\n      handleSend,\n      formatTimestamp,\n      todayEmailDate,\n      onUnderstandClick,\n      isLoadingRole,\n      isReadyToSend,\n      onInputKeyDown,\n      botSendMessage,\n    }\n  }\n});\n\n\n//# sourceURL=webpack://ruby-openai/./frontend_app/pages/PreTask.vue?./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("4a2359f65ba19101ba19")
/******/ })();
/******/ 
/******/ }
);